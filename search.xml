<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>STM32学习(一)----LCD屏幕(FSMC)</title>
      <link href="/2023/02/15/stm3201/"/>
      <url>/2023/02/15/stm3201/</url>
      
        <content type="html"><![CDATA[<h1 id="FSMC简述"><a href="#FSMC简述" class="headerlink" title="FSMC简述"></a>FSMC简述</h1><ul><li><p>大容量，且引脚数在 100 脚以上的 STM32F103 芯片都带有 FSMC 接口。</p></li><li><p>FSMC，即灵活的静态存储控制器flexible static memory controller。</p></li></ul><h2 id="扩展内存"><a href="#扩展内存" class="headerlink" title="扩展内存"></a>扩展内存</h2><ul><li>STM32 的 FSMC 接口支持包括 SRAM、NAND FLASH、NOR FLASH 和 PSRAM 等存储器。</li></ul><p><img src="https://cdn.staticaly.com/gh/QM1412/blog_bed@main/img/image-20230215142551415.png" alt="image-20230215142551415"></p><ul><li>FSMC就是一个MCU与外部存储器（SRAM,FLASH等）读写数据的一个接口</li></ul><h1 id="FSMC内部原理"><a href="#FSMC内部原理" class="headerlink" title="FSMC内部原理"></a>FSMC内部原理</h1><h2 id="FSMC-的框图"><a href="#FSMC-的框图" class="headerlink" title="FSMC 的框图"></a>FSMC 的框图</h2><p><img src="https://cdn.staticaly.com/gh/QM1412/blog_bed@main/img/image-20230215142930470.png" alt="image-20230215142930470"></p><ul><li><strong>NE[4-1] 片选,用来区分不同设备</strong></li><li><strong>NWE为写。</strong></li><li><strong>NOE为读</strong><ul><li>n低电平有效</li><li>o output</li><li>e 使能<br><img src="https://cdn.staticaly.com/gh/QM1412/blog_bed@main/img/image-20230215181515867.png" alt="image-20230215181515867"></li></ul></li></ul><h3 id="驱动SRAM"><a href="#驱动SRAM" class="headerlink" title="驱动SRAM"></a>驱动SRAM</h3><ul><li>FSMC驱动外部SRAM时，外部SRAM的控制一般有<ul><li>地址线（如A0-A25）</li><li>数据线（如D0-D15）</li><li>写信号（WE，即WR）</li><li>读信号（OE，即RD）</li><li>片选信号（CS）</li><li>如果SRAM支持字节控制，那么还有UB/LB信号。</li></ul></li></ul><h3 id="驱动TFTLCD"><a href="#驱动TFTLCD" class="headerlink" title="驱动TFTLCD"></a>驱动TFTLCD</h3><ul><li>真正在操作LCD的时候需要用到的就只有：<ul><li>RS、D0~D15、WR、RD和CS。</li></ul></li><li>其操作时序和SRAM的控制完全类似，唯一不同就是TFTLCD有RS信号，但是没有地址信号。(所以将RS当做地址线来用)</li></ul><p><img src="https://cdn.staticaly.com/gh/QM1412/blog_bed@main/img/image-20230215143936618.png" alt="image-20230215143936618"></p><p><img src="https://cdn.staticaly.com/gh/QM1412/blog_bed@main/img/image-20230215143952237.png" alt="image-20230215143952237"></p><p><code>(该表格为F407的，与103不太一样，仅看个大概意思)</code></p><ul><li>TFTLCD通过RS信号来决定传送的数据是数据还是命令，本质上可以理解为一个地址信号<ul><li>比如我们把*RS接在A0上面</li><li>那么<strong>当FSMC控制器写地址0的时候，会使得A0变为0，对TFTLCD来说，就是写命令。而FSMC写地址1的时候，A0将会变为1，对TFTLCD来说，就是写数据了</strong></li><li>当然RS也可以接在其他地址线上</li></ul></li><li>因此，可以把TFTLCD当成一个SRAM来用，只不过这个SRAM有2个地址，这就是FSMC可以驱动LCD的原理。</li></ul><h1 id="FSMC内存划分"><a href="#FSMC内存划分" class="headerlink" title="FSMC内存划分"></a>FSMC内存划分</h1><h2 id="FSMC的分块-存储块一的介绍"><a href="#FSMC的分块-存储块一的介绍" class="headerlink" title="FSMC的分块(存储块一的介绍)"></a>FSMC的分块(存储块一的介绍)</h2><p>​    STM32的 FSMC将外部存储器划分为固定大小为 256M 字节的四个存储块（Bank），FSMC 总共管理 1GB 空间.如下为FSMC在CPU中的地址映射划分。</p><p><img src="https://cdn.staticaly.com/gh/QM1412/blog_bed@main/img/image-20230215144724020.png" alt="image-20230215144724020"></p><p>​    各个模块的控制范围:</p><p><img src="https://cdn.staticaly.com/gh/QM1412/blog_bed@main/img/image-20230215144816108.png" alt="image-20230215144816108"></p><h2 id="NOR和PSRAM地址映像"><a href="#NOR和PSRAM地址映像" class="headerlink" title="NOR和PSRAM地址映像"></a>NOR和PSRAM地址映像</h2><p>​    HADDR[27:26]位用于选择四个存储块之一：</p><div class="table-container"><table><thead><tr><th style="text-align:center">HADDR[27:26]</th><th style="text-align:center">选择的存储块</th></tr></thead><tbody><tr><td style="text-align:center">00</td><td style="text-align:center">存储块1 NOR/PSRAM 1</td></tr><tr><td style="text-align:center">01</td><td style="text-align:center">存储块1 NOR/PSRAM 2</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">存储块1 NOR/PSRAM 3</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">存储块1 NOR/PSRAM 3</td></tr></tbody></table></div><h3 id="不同数据宽度对存储块1寻址的影响"><a href="#不同数据宽度对存储块1寻址的影响" class="headerlink" title="不同数据宽度对存储块1寻址的影响"></a>不同数据宽度对存储块1寻址的影响</h3><p>HADDR是需要转换到外部存储器的内部AHB地址线。HADDR[25:0]包含外部存储器地址。HADDR是字节地址，而存储器访问不都是按字节访问，因此接到存储器的地址线依存储器的数据宽度有所不同，如下表:</p><p><img src="https://cdn.staticaly.com/gh/QM1412/blog_bed@main/img/image-20230215145845505.png" alt="image-20230215145845505"></p><p>需要或者可以访问的地址空间大小。</p><ul><li>当Bank1接的是16位宽度存储器的时候：HADDR[25:1]，FSMC_A[24:0]</li><li>当Bank1接的是8位宽度存储器的时候：HADDR[25:0]，FSMC_A[25:0]</li></ul><p><strong>不论外部接8位/16位宽设备，FSMC_A[0]永远接在外部设备地址A[0]</strong></p><p>这里需要注意的是：</p><p><strong>这个地址映射，指的是你选择的数据宽度是哪种，然后对应会映射到哪种 </strong></p><blockquote><ul><li><strong>数据宽度为8位时：比如HADDR映射的基地址是0x68000000，那么对于FSMC来说，也就是外部存储器就是0x00000000的地址，若HADDR内部地址+1变成0x68000001，那么外部地址也随着+1，变成0x00000001</strong></li><li><strong>数据宽度16位：比如HADDR映射的基地址是0x68000000，那么对于FSMC来说，也就是外部存储器就是0x00000000的地址，若HADDR内部地址+1变成0x68000001，但是由于HADDR的HADDR[1]与FSMC[0]相邻，反而左移了一位，映射到外部存储器的地址反而是0x00000002,同理，若内部+2，则外部就映射到0x00000004</strong></li></ul></blockquote><h2 id="FSMC中地址与外设地址的对应关系"><a href="#FSMC中地址与外设地址的对应关系" class="headerlink" title="FSMC中地址与外设地址的对应关系"></a>FSMC中地址与外设地址的对应关系</h2><p>​    FSMC中的1G空间存储的是外设地址，当我们在存储块中的访问单元序号+1，对应的外设存储单元的访问地址就自加8（如果外设数据存储的数据宽度为8b的话）</p><p><img src="https://cdn.staticaly.com/gh/QM1412/blog_bed@main/img/image-20230215150536729.png" alt="image-20230215150536729"></p><h1 id="STM32-的FSMC-模拟8080-接口时序"><a href="#STM32-的FSMC-模拟8080-接口时序" class="headerlink" title="STM32 的FSMC 模拟8080 接口时序"></a>STM32 的FSMC 模拟8080 接口时序</h1><p>​    ILI9341 的 8080 通讯接口时序可以由 STM32 使用普通 I/O 接口进行模拟，但这样效率太低，STM32 提供了一种特别的控制方法——使用 FSMC 接口实现 8080 时序。</p><h2 id="FSMC控制异步NORFLASH的时序"><a href="#FSMC控制异步NORFLASH的时序" class="headerlink" title="FSMC控制异步NORFLASH的时序"></a>FSMC控制异步NORFLASH的时序</h2><p>​    FSMC 外设支持输出多种不同的时序以便于控制不同的存储器，它具有 ABCD 四种模式，下面我们仅针对控制异步 NOR FLASH 使用的模式 B 进行讲解，见图 <em>FSMC</em> 写 <em>NOR_FLASH</em> 的时序图 。</p><ul><li><strong>读时序</strong></li></ul><p><img src="https://cdn.staticaly.com/gh/QM1412/blog_bed@main/img/image-20230215181408000.png" alt="image-20230215181408000"></p><ul><li><strong>写时序</strong></li></ul><p><img src="https://cdn.staticaly.com/gh/QM1412/blog_bed@main/img/image-20230215181808866.png" alt="image-20230215181808866"></p><p>​    当内核发出访问某个指向外部存储器地址时，FSMC 外设会根据配置控制信号线产生时序访问存储器，上图中的是访问外部异步 NOR FLASH（模式 B）时 FSMC 外设的读写时序。</p><p>​    以读时序为例，该图表示一个存储器操作周期由地址建立周期 (ADDSET)、数据建立周期(DATAST) 以及 2 个 HCLK 周期组成。在地址建立周期中，地址线发出要访问的地址，数据掩码信号线指示出要读取地址的高、低字节部分，片选信号使能存储器芯片；地址建立周期结束后读使能信号线发出读使能信号，接着存储器通过数据信号线把目标数据传输给 FSMC，FSMC 把它交给内核。</p><p>​    写时序类似，区别是它的一个存储器操作周期仅由地址建立周期 (ADDSET) 和数据建立周期(DATAST) 组成，且在数据建立周期期间写使能信号线发出写信号，接着 FSMC 把数据通过数据线传输到存储器中。</p><p>​    根据 STM32 对寻址空间的地址映射，地址 0x6000 0000 ~0x9FFF FFFF 是<code>映射</code>到外部存储器的，而其中的<strong>0x6000 0000 ~0x6FFF FFFF 则是分配给 NOR FLASH、PSRAM 这类可直接寻址的器件。</strong></p><p>​    当 FSMC 外设被配置成正常工作，并且外部接了 NOR FLASH 时，若向 0x60000000 地址写入数据如 0xABCD，FSMC 会自动在各信号线上产生相应的电平信号，写入数据。FSMC 会控制片选信号 NE1 选择相应的 NOR 芯片，然后使用地址线 A[25:0] 输出 0x60000000，在 NWE 写使能信号线上发出低电平的写使能信号，而要写入的数据信号 0xABCD 则从数据线 D[15:0] 输出，然后数据就被保存到 NOR FLASH 中了。</p><h2 id="用FSMC模拟8080时序"><a href="#用FSMC模拟8080时序" class="headerlink" title="用FSMC模拟8080时序"></a>用FSMC模拟8080时序</h2><p><img src="https://cdn.staticaly.com/gh/QM1412/blog_bed@main/img/image-20230215182302111.png" alt="image-20230215182302111"></p><p>​    对比 FSMC NOR/PSRAM 中的模式 B 时序与 ILI9341液晶控制器芯片使用的 8080 时序可发现，这两个时序是十分相似的 (除了 FSMC 的地址线 A 和8080 的 D/CX 线，可以说是完全一样)。</p><p><img src="https://cdn.staticaly.com/gh/QM1412/blog_bed@main/img/image-20230215183402410.png" alt="image-20230215183402410"></p><p>​    对于 FSMC 和 8080 接口，前四种信号线都是完全一样的，仅仅是 FSMC 的地址信号线 A[25:0] 与8080 的数据/命令选择线 D/CX 有区别。而对于 D/CX 线，它为高电平的时候表示数值，为低电平的时候表示命令，如果能使用 FSMC 的 A 地址线根据不同的情况产生对应的电平，那么就完全可以使用 FSMC 来产生 8080 接口需要的时序了。</p><p>​    为了模拟出 8080 时序，我们可以把 FSMC 的 A0 地址线 (也可以使用其它 A1/A2 等地址线) 与ILI9341 芯片 8080 接口的 D/CX 信号线连接，那么当 A0 为高电平时 (即 D/CX 为高电平)，数据线 D[15:0] 的信号会被 ILI9341 理解为数值，若 A0 为低电平时 (即 D/CX 为低电平)，传输的信号则会被理解为命令。</p><blockquote><ul><li>当使用 FSMC 向 0x6xxx xxx1、0x6xxx xxx3、0x6xxx xxx5…这些奇数地址写入数据时，地址最低位的值均为 1，所以它会控制地址线 A0(D/CX) 输出高电平，那么这时通过数据线传输的信号会被理解为数值；</li><li>若向 0x6xxx xxx0 、0x6xxx xxx2、0x6xxx xxx4…这些偶数地址写入数据时，地址最低位的值均为 0，所以它会控制地址线 A0(D/CX) 输出低电平，因此这时通过数据线传输的信号会被理解为命令</li></ul></blockquote><p><code>见表使用 *FSMC* 输出地址示例 :</code></p><p><img src="https://cdn.staticaly.com/gh/QM1412/blog_bed@main/img/image-20230215183740083.png" alt="image-20230215183740083"></p><p><strong>注意：在实际控制时，以上地址计算方式还不完整，还需要注意 HADDR 内部地址与 FSMC 地址信号线的转换。</strong></p><h1 id="FSMC结构体"><a href="#FSMC结构体" class="headerlink" title="FSMC结构体"></a>FSMC结构体</h1><h2 id="NORFLASH时序结构体"><a href="#NORFLASH时序结构体" class="headerlink" title="NORFLASH时序结构体"></a>NORFLASH时序结构体</h2><p>控制 FSMC 使用 NOR FLASH 存储器时主要是配置时序寄存器以及控制寄存器，利用 ST 标准库的时序结构体以及初始化结构体可以很方便地写入参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> FSMC_AddressSetupTime;      <span class="comment">/* 地址建立时间，0-0xF 个 HCLK 周期 */</span></span><br><span class="line">    <span class="type">uint32_t</span> FSMC_AddressHoldTime;       <span class="comment">/* 地址保持时间，0-0xF 个 HCLK 周期 */</span></span><br><span class="line">    <span class="type">uint32_t</span> FSMC_DataSetupTime;         <span class="comment">/* 地址建立时间，0-0xF 个 HCLK 周期 */</span></span><br><span class="line">    <span class="type">uint32_t</span> FSMC_BusTurnAroundDuration; <span class="comment">/* 总线转换周期,0-0xF 个 HCLK 周期，在 NOR*/</span></span><br><span class="line">    <span class="type">uint32_t</span> FSMC_CLKDivision;           <span class="comment">/* 时钟分频因子,1-0xF，若控制异步存储器，本参数无效 */</span></span><br><span class="line">    <span class="type">uint32_t</span> FSMC_DataLatency;           <span class="comment">/* 数据延迟时间，若控制异步存储器，本参数无效 */</span></span><br><span class="line">    <span class="type">uint32_t</span> FSMC_AccessMode;            <span class="comment">/* 设置访问模式 */</span></span><br><span class="line">&#125; FSMC_NORSRAMTimingInitTypeDef;</span><br></pre></td></tr></table></figure><h2 id="FSMC初始化结构体"><a href="#FSMC初始化结构体" class="headerlink" title="FSMC初始化结构体"></a>FSMC初始化结构体</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> FSMC_Bank;            <span class="comment">/* 设置要控制的 Bank 区域 */</span></span><br><span class="line">    <span class="type">uint32_t</span> FSMC_DataAddressMux;  <span class="comment">/* 设置地址总线与数据总线是否复用 */</span></span><br><span class="line">    <span class="type">uint32_t</span> FSMC_MemoryType;      <span class="comment">/* 设置存储器的类型 */</span></span><br><span class="line">    <span class="type">uint32_t</span> FSMC_MemoryDataWidth; <span class="comment">/* 设置存储器的数据宽度 */</span></span><br><span class="line">    <span class="type">uint32_t</span> FSMC_BurstAccessMode; <span class="comment">/* 设置是否支持突发访问模式，只支持同步类型的存储器*/</span></span><br><span class="line">    <span class="type">uint32_t</span> FSMC_AsynchronousWait;   <span class="comment">/* 设置是否使能在同步传输时的等待信号，*/</span></span><br><span class="line">    <span class="type">uint32_t</span> FSMC_WaitSignalPolarity; <span class="comment">/* 设置等待信号的极性 */</span></span><br><span class="line">    <span class="type">uint32_t</span> FSMC_WrapMode;           <span class="comment">/* 设置是否支持对齐的突发模式 */</span></span><br><span class="line">    <span class="type">uint32_t</span> FSMC_WaitSignalActive;   <span class="comment">/* 配置等待信号在等待前有效还是等待期间有效 */</span></span><br><span class="line">    <span class="type">uint32_t</span> FSMC_WriteOperation;     <span class="comment">/* 设置是否写使能 */</span></span><br><span class="line">    <span class="type">uint32_t</span> FSMC_WaitSignal;         <span class="comment">/* 设置是否使能等待状态插入 */</span></span><br><span class="line">    <span class="type">uint32_t</span> FSMC_ExtendedMode;       <span class="comment">/* 设置是否使能扩展模式 */</span></span><br><span class="line">    <span class="type">uint32_t</span> FSMC_WriteBurst;         <span class="comment">/* 设置是否使能写突发操作 */</span></span><br><span class="line">    <span class="comment">/* 当不使用扩展模式时，本参数用于配置读写时序，否则用于配置读时序 */</span></span><br><span class="line">    FSMC_NORSRAMTimingInitTypeDef *FSMC_ReadWriteTimingStruct;</span><br><span class="line">    <span class="comment">/* 当使用扩展模式时，本参数用于配置写时序 */</span></span><br><span class="line">    FSMC_NORSRAMTimingInitTypeDef *FSMC_WriteTimingStruct;</span><br><span class="line">&#125; FSMC_NORSRAMInitTypeDef;</span><br></pre></td></tr></table></figure><p>(1) FSMC_Bank</p><p>​    本成员用于选择 FSMC 映射的存储区域，它的可选参数以及相应的内核地址映射范围见表可以选择的存储器区域及区域对应的地址范围 </p><p><img src="https://cdn.staticaly.com/gh/QM1412/blog_bed@main/img/image-20230215184555289.png" alt="image-20230215184555289"></p><p>(2)FSMC_ExtendedMode本成员用于设置是否使用<strong>扩展模式 </strong>(FSMC_ExtendedMode_Enable/Disable)，在非扩展模式下，对存储器读写的时序都只使用 FSMC_BCR 寄存器中的配置，即下面的FSMC_ReadWriteTimingStruct 结构体成员；<strong>在扩展模式下</strong>，对存储器的读写时序可以分开配置，<strong>读时序使用 FSMC_BCR 寄存器，写时序使用 FSMC_BWTR 寄存器的配置</strong>，即后面的 FSMC_WriteTimingStruct 结构体成员。</p>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreeRTOS(五)----内存管理</title>
      <link href="/2023/02/14/freertos05/"/>
      <url>/2023/02/14/freertos05/</url>
      
        <content type="html"><![CDATA[<h1 id="一、内存管理基本概�"><a href="#一、内存管理基本概�" class="headerlink" title="一、内存管理基本概�?"></a>一、内存管理基本概�?</h1><p>FreeRTOS 内存管理模块管理用于系统中内存资源，它是操作系统的核心模块之一。主要包括内存的初始化、分配以及释放�?</p><p>很多人会有疑问，什么不直接使用 C 标准库中的内存管理函数呢？在电脑中我们可以用 malloc()�? free()这两个函数动态的分配内存和释放内存。但是，在嵌入式实时操作系统中，调用 malloc()�? free()却是危险的，原因有以下几点：</p><blockquote><ul><li><p>这些函数在小型嵌入式系统中并不总是可用的，小型嵌入式设备中�? RAM 不足�?</p></li><li><p>它们的实现可能非常的大，占据了相当大的一块代码空间�?</p></li><li><p>他们几乎都不是安全的�?</p></li><li><p>它们并不是确定的，每次调用这些函数执行的时间可能都不一样�?</p></li><li><p>它们有可能产生碎片。（就是内存会越切越小）</p></li><li><p>这两个函数会使得链接器配置得复杂�?</p></li><li><p>如果允许堆空间的生长方向覆盖其他变量占据的内存，它们会成�? debug 的灾难�?</p></li></ul></blockquote><p>FreeRTOS 对内存管理做了很多事情，FreeRTOS �? V9.0.0 版本为我们提供了 5 种内存管理算法，分别�? heap_1.c、heap_2.c、heap_3.c、heap_4.c、heap_5.c，源文件存放于FreeRTOS\Source\portable\MemMang 路径下，在使用的时候选择其中一个添加到我们的工程中去即可�?</p><p>FreeRTOS内核规定的几个内存管理函数原型为�?</p><blockquote><p><strong>void *pvPortMalloc( size_t xSize ) ：内存申请函�?</strong><br><strong>void vPortFree( void *pv ) ：内存释放函�?</strong><br><strong>void vPortInitialiseBlocks( void ) ：初始化内存堆函�?</strong><br><strong>size_t xPortGetFreeHeapSize( void ) ：获取当前未分配的内存堆大小</strong><br><strong>size_t xPortGetMinimumEverFreeHeapSize( void )：获取未分配的内存堆历史最小�?</strong></p></blockquote><h1 id="二、内存管理方案详�"><a href="#二、内存管理方案详�" class="headerlink" title="二、内存管理方案详�?"></a>二、内存管理方案详�?</h1><p>对于 heap_1.c、heap_2.c �? heap_4.c 这三种内存管理方案，内存堆实际上是一个很大的 <strong>�? �?</strong> �? �? �? �? static uint8_t ucHeap[ configTOTAL_HEAP_SIZE] �? �? �? �? 义configTOTAL_HEAP_SIZE 则表示系统管理内存大小，单位为字，在 FreeRTOSConfig.h 中由用户设定�?</p><p>对于 heap_3.c 这种内存管理方案，它封装�? C 标准库中�? malloc()�? free()函数，封装后�? malloc()�? free()函数具备保护，可以安全在嵌入式系统中执行。因此，用户需要通过编译器或者启动文件设置堆空间。heap_5.c 方案允许用户使用多个非连续内存堆空间，每个内存堆的起始地址和大小由用户定义。这种应用其实还是很大的，比如做图形显示、GUI 等，可能芯片内部�? RAM是不够用户使用的，需要外�? SDRAM，那这种内存管理方案则比较合适�?</p><h2 id="1、heap-1-c"><a href="#1、heap-1-c" class="headerlink" title="1、heap_1.c"></a>1、heap_1.c</h2><p>heap_1.c 管理方案�? FreeRTOS 提供所有内存管理方案中最简单的一个，它只能申请内存而不能进行内存释放，并且申请内存的时间是一个常量，这样子对于要求安全的嵌入式设备来说是最好的，因为不允许内存释放，就不会产生内存碎片而导致系统崩溃，但是也有缺点，那就是内存利用率不高，某段内存只能用于内存申请的地方，即使该内存只使用一次，也无法让系统回收重新利用�?</p><p>heap1.c 方案具有以下特点�?</p><ol><li>用于从不删除任务、队列、信号量、互斥量等的应用程序（实际上大多数使用FreeRTOS 的应用程序都符合这个条件）�?</li><li>函数的执行时间是确定的并且不会产生内存碎片�?</li></ol><p>这个内存管理策略使用两个局部静态变量来跟踪内存分配，变量定义为�?</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span> xNextFreeByte = ( <span class="type">size_t</span> ) <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> *pucAlignedHeap = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p><strong>1.1内存申请：pvPortMalloc()</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">pvPortMalloc</span><span class="params">( <span class="type">size_t</span> xWantedSize )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span> *pvReturn = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> *pucAlignedHeap = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 确保申请的字节数是对齐字节数的倍数 */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span>( portBYTE_ALIGNMENT != 1 )</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( xWantedSize &amp; portBYTE_ALIGNMENT_MASK )</span><br><span class="line">        &#123;</span><br><span class="line">            xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize &amp; portBYTE_ALIGNMENT_MASK ) );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    vTaskSuspendAll();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( pucAlignedHeap == <span class="literal">NULL</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 第一次使�?,确保内存堆起始位置正确对�? */</span></span><br><span class="line">            pucAlignedHeap = ( <span class="type">uint8_t</span> * ) ( ( ( portPOINTER_SIZE_TYPE ) &amp;ucHeap[ portBYTE_ALIGNMENT ] ) &amp; ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* 边界检�?,变量xNextFreeByte是局部静态变�?,初始值为0 */</span></span><br><span class="line">        <span class="keyword">if</span>( ( ( xNextFreeByte + xWantedSize ) &lt; configADJUSTED_HEAP_SIZE ) &amp;&amp;</span><br><span class="line">            ( ( xNextFreeByte + xWantedSize ) &gt; xNextFreeByte ) )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 返回申请的内存起始地址并更新索�? */</span></span><br><span class="line">            pvReturn = pucAlignedHeap + xNextFreeByte;</span><br><span class="line">            xNextFreeByte += xWantedSize;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ( <span class="type">void</span> ) xTaskResumeAll();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="meta">#<span class="keyword">if</span>( configUSE_MALLOC_FAILED_HOOK == 1 )</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( pvReturn == <span class="literal">NULL</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">vApplicationMallocFailedHook</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line">            vApplicationMallocFailedHook();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> pvReturn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>�? �? �? �? �? �? �? �? �? �? �? �? 需 �? �? �? �? �? �? �? �? �? �? �? �? �? 需 �? �? �? 量pucAlignedHeap 指向内存域第一个地址对齐处，因为系统管理的内存其实是一个大数组，而编译器为这个数组分配的起始地址是随机的，不一定符合系统的对齐要求，这时候要进行内存地址对齐操作。比如数�? ucHeap 的地址�? 0x20000123 处开始，系统按照 8 字节对齐,如下�?:</p><p><img src="https://cdn.staticaly.com/gh/QM1412/blog_bed@main/img/image-20230214190355481.png" alt="image-20230214190355481"></p><p>在内存对齐完成后，用户想要申请一�? 30字节大小的内存，那么按照系统对齐的要求，我们会申请到 32 个字节大小的内存空间，即使我们只需�? 30 字节的内存，申请完成的示意图具体如下:</p><p><img src="https://img1.imgtp.com/2023/02/14/mfGSBYDq.png" alt="image-20230214190445976"></p><h2 id="2、heap-2-c"><a href="#2、heap-2-c" class="headerlink" title="2、heap_2.c"></a>2、heap_2.c</h2><p>heap_2.c 方案�? heap_1.c 方案采用的内存管理算法不一样，它采用一种最佳匹配算�?(best fit algorithm)，比如我们申�? 100 字节的内存，而可申请内存中有三块对应大小 200 字节�? 500 字节�? 1000 字节大小的内存块，按照算法的最佳匹配，这时候系统会�? 200 字节大小的内存块进行分割并返回申请内存的起始地址，剩余的内存则插回链表留待下次申请。Heap_2.c 方案支持释放申请的内存，但是它不能把相邻的两个小的内存块合成一个大的内存块，对于每次申请内存大小都比较固定的，这个方式是没有问题的，而对于每次申请并不是固定内存大小的则会造成内存碎片，后面要讲解�? heap_4.c 方案采用的内存管理算法能解决内存碎片的问题，可以把这些释放的相邻的小的内存块合并成一个大的内存块�?</p><p>同样�? ，内存分配时需 要的总的内存�? 空间由文 �? FreeRTOSConfig.h 中的 宏configTOTAL_HEAP_SIZE 配置，单位为字。通过调用函数 xPortGetFreeHeapSize() 我们可同样的 ，内存分配时需 要的总的内存�? 空间由文 �? FreeRTOSConfig.h 中configTOTAL_HEAP_SIZE 配置，单位为字。通过调用函数 xPortGetFreeHeapSize() 我们可以知道还剩下多少内存没有使用，但是并不包括内存碎片，这样一来我们可以实时的调整和优�? configTOTAL_HEAP_SIZE 的大小�?</p><p><strong>heap_2.c 方案具有以下特点�?</strong></p><blockquote><ol><li>可以用在那些反复的删除任务、队列、信号量、等内核对象且不担心内存碎片的应用程序�?</li><li>如果我们的应用程序中的队列、任务、信号量、等工作在一个不可预料的顺序，这样子也有可能会导致内存碎片�?</li><li>具有不确定性，但是效率比标�? C 库中�? malloc 函数高得多�?</li><li>不能用于那些内存分配和释放是随机大小的应用程序�?</li></ol></blockquote><p>heap_2.c 方案采用链表的数据结构记录空闲内存块，将所有的空闲内存块组成一个空闲内存块链表，FreeRTOS 采用 2 �? BlockLink_t 类型的局部静态变�? xStart、xEnd 来标识空闲内存块链表的起始位置与结束位置，空闲内存块链表结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">A_BLOCK_LINK</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A_BLOCK_LINK</span> *<span class="title">pxNextFreeBlock</span>;</span><span class="comment">//pxNextFreeBlock 成员变量是指向下一个空闲内存块的指针�?</span></span><br><span class="line"><span class="type">size_t</span> xBlockSize;  <span class="comment">//xBlockSize 用于记录申请的内存块的大小，包括链表结构体大小�?</span></span><br><span class="line">&#125; BlockLink_t;</span><br></pre></td></tr></table></figure><h3 id="初始化prvHeapInit-函数"><a href="#初始化prvHeapInit-函数" class="headerlink" title="初始化prvHeapInit()函数"></a>初始化prvHeapInit()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">prvHeapInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    BlockLink_t *pxFirstFreeBlock;</span><br><span class="line">    <span class="type">uint8_t</span> *pucAlignedHeap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 保证 pucAlignedHeap 也是按照指定内存要求对齐�? */</span></span><br><span class="line">    pucAlignedHeap = (<span class="type">uint8_t</span> *)(((portPOINTER_SIZE_TYPE)&amp;ucHeap[portBYTE_ALIGNMENT]) &amp; (~((portPOINTER_SIZE_TYPE)portBYTE_ALIGNMENT_MASK)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 空闲内存链表头部初始�? */</span></span><br><span class="line">    xStart.pxNextFreeBlock = (<span class="type">void</span> *)pucAlignedHeap;</span><br><span class="line">    xStart.xBlockSize = (<span class="type">size_t</span>)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 空闲内存链表尾部初始�? */</span></span><br><span class="line">    xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;</span><br><span class="line">    xEnd.pxNextFreeBlock = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* �? pxFirstFreeBlock 放入空闲链表中，因为空闲内存块链表除了要有头部与尾部�?</span></span><br><span class="line"><span class="comment">    还需要有真正可用的内存，而第一块可用的内存就是 pxFirstFreeBlock�?</span></span><br><span class="line"><span class="comment">    pxFirstFreeBlock 的大小是系统管理的内存大�? configADJUSTED_HEAP_SIZE */</span></span><br><span class="line">    pxFirstFreeBlock = (<span class="type">void</span> *)pucAlignedHeap;</span><br><span class="line">    pxFirstFreeBlock-&gt;xBlockSize = configADJUSTED_HEAP_SIZE;</span><br><span class="line">    pxFirstFreeBlock-&gt;pxNextFreeBlock = &amp;xEnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局部静态变量pucAlignedHeap指向对齐后的内存堆起始位置。地址对齐的原因在第一种内存管理策略中已经说明。假如内存堆数ucHeap从RAM地址0x10002003处开始，系统按照8字节对齐，则对齐后的内存堆与第一个内存管理策略一样，如图:</p><p><img src="https://img1.imgtp.com/2023/02/14/hQWb2ZdY.png" alt="image-20230214192646068"  /></p><p>空闲内存块的初始化就分析完成，将内存块以链表的形式去管理，初始化完成示意图具体如�?:</p><p><img src="https://img1.imgtp.com/2023/02/14/ddNkS3Wj.png" alt="image-20230214193153123"></p><h3 id="内存申请pvPortMalloc-函数"><a href="#内存申请pvPortMalloc-函数" class="headerlink" title="内存申请pvPortMalloc()函数"></a>内存申请pvPortMalloc()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">pvPortMalloc</span><span class="params">( <span class="type">size_t</span> xWantedSize )</span></span><br><span class="line">&#123;</span><br><span class="line">BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;</span><br><span class="line"><span class="type">static</span> BaseType_t xHeapHasBeenInitialised = pdFALSE;</span><br><span class="line"><span class="type">void</span> *pvReturn = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/* 挂起调度�? */</span></span><br><span class="line">    vTaskSuspendAll();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 如果是第一次调用内存分配函�?,这里先初始化内存�?,如图2-2所�? */</span></span><br><span class="line">        <span class="keyword">if</span>( xHeapHasBeenInitialised == pdFALSE )</span><br><span class="line">        &#123;</span><br><span class="line">            prvHeapInit();</span><br><span class="line">            xHeapHasBeenInitialised = pdTRUE;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* 调整要分配的内存�?,需要增加上链表结构体空�?,heapSTRUCT_SIZE表示经过对齐扩展后的结构体大�? */</span></span><br><span class="line">        <span class="keyword">if</span>( xWantedSize &gt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            xWantedSize += heapSTRUCT_SIZE;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            <span class="comment">/* 调整实际分配的内存大�?,向上扩大到对齐字节数的整数�? */</span></span><br><span class="line">            <span class="keyword">if</span>( ( xWantedSize &amp; portBYTE_ALIGNMENT_MASK ) != <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize &amp; portBYTE_ALIGNMENT_MASK ) );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>( ( xWantedSize &gt; <span class="number">0</span> ) &amp;&amp; ( xWantedSize &lt; configADJUSTED_HEAP_SIZE ) )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 空闲内存块是按照块的大小排序�?,从链表头xStart开�?,小的在前大的在后,以链表尾xEnd结束 */</span></span><br><span class="line">            pxPreviousBlock = &amp;xStart;</span><br><span class="line">            pxBlock = xStart.pxNextFreeBlock;</span><br><span class="line">            <span class="comment">/* 搜索最合适的空闲�? */</span></span><br><span class="line">            <span class="keyword">while</span>( ( pxBlock-&gt;xBlockSize &lt; xWantedSize ) &amp;&amp; ( pxBlock-&gt;pxNextFreeBlock != <span class="literal">NULL</span> ) )</span><br><span class="line">            &#123;</span><br><span class="line">                pxPreviousBlock = pxBlock;</span><br><span class="line">                pxBlock = pxBlock-&gt;pxNextFreeBlock;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            <span class="comment">/* 如果搜索到链表尾xEnd,说明没有找到合适的空闲内存�?,否则进行下一步处�? */</span></span><br><span class="line">            <span class="keyword">if</span>( pxBlock != &amp;xEnd )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* 返回内存空间,注意是跳过了结构体BlockLink_t空间. */</span></span><br><span class="line">                pvReturn = ( <span class="type">void</span> * ) ( ( ( <span class="type">uint8_t</span> * ) pxPreviousBlock-&gt;pxNextFreeBlock ) + heapSTRUCT_SIZE);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">                <span class="comment">/* 这个块就要返回给用户,因此它必须从空闲块中去除. */</span></span><br><span class="line">                pxPreviousBlock-&gt;pxNextFreeBlock = pxBlock-&gt;pxNextFreeBlock;</span><br><span class="line">                <span class="comment">/* 如果这个块剩余的空间足够�?,则将它分成两�?,第一个返回给用户,第二个作为新的空闲块插入到空闲块列表中去*/</span></span><br><span class="line">                <span class="keyword">if</span>( ( pxBlock-&gt;xBlockSize - xWantedSize ) &gt; heapMINIMUM_BLOCK_SIZE )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* 去除分配出去的内�?,在剩余内存块的起始位置放置一个链表结构并初始化链表成�? */</span></span><br><span class="line">                    pxNewBlockLink = ( <span class="type">void</span> * ) ( ( ( <span class="type">uint8_t</span> * ) pxBlock ) + xWantedSize );</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">                    pxNewBlockLink-&gt;xBlockSize = pxBlock-&gt;xBlockSize - xWantedSize;</span><br><span class="line">                    pxBlock-&gt;xBlockSize = xWantedSize;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">                    <span class="comment">/* 将剩余的空闲块插入到空闲块列表中,按照空闲块的大小顺序,小的在前大的在后 */</span></span><br><span class="line">                    prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/* 计算未分配的内存堆大�?,注意这里并不能包含内存碎片信�? */</span></span><br><span class="line">                xFreeBytesRemaining -= pxBlock-&gt;xBlockSize;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        traceMALLOC( pvReturn, xWantedSize );</span><br><span class="line">    &#125;</span><br><span class="line">    ( <span class="type">void</span> ) xTaskResumeAll();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="meta">#<span class="keyword">if</span>( configUSE_MALLOC_FAILED_HOOK == 1 )</span></span><br><span class="line">    &#123;   <span class="comment">/* 如果内存分配失败,调用钩子函数 */</span></span><br><span class="line">        <span class="keyword">if</span>( pvReturn == <span class="literal">NULL</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">vApplicationMallocFailedHook</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line">            vApplicationMallocFailedHook(); <span class="comment">//错误一般都是内存不足，这个函数就是打印一些错误消息的</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> pvReturn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随着内存申请，越来越多申请的内存块脱离空闲内存链表，但链表仍是以 xStart 节点开头以 xEnd 节点结尾，空闲内存块链表根据空闲内存块的大小进行排序。每当用户申请一次内存的时候，系统都要分配一�? BlockLink_t 类型结构体空间，用于保存申请的内存块信息，并且每个内存块在申请成功后会脱离空闲内存块链表，申请两次后的内存示意图具体见图�?</p><p><img src="https://img1.imgtp.com/2023/02/14/Unq8ANxV.png" alt="image-20230214193506420"></p><h3 id="内存释放函数-vPortFree"><a href="#内存释放函数-vPortFree" class="headerlink" title="内存释放函数 vPortFree()"></a>内存释放函数 vPortFree()</h3><p>这个函数比较简单，就直接看源码就好�?</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vPortFree</span><span class="params">( <span class="type">void</span> *pv )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> *puc = ( <span class="type">uint8_t</span> * ) pv;</span><br><span class="line">BlockLink_t *pxLink;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>( pv != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 根据传入的参数找到链表结�? */</span></span><br><span class="line">        puc -= heapSTRUCT_SIZE;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* 预防某些编译器警�? */</span></span><br><span class="line">        pxLink = ( <span class="type">void</span> * ) puc;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        vTaskSuspendAll();</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 将这个块添加到空闲块列表 */</span></span><br><span class="line">            prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );<span class="comment">//直接将内存块按从小到大插入就好了</span></span><br><span class="line">            <span class="comment">/* 更新未分配的内存堆大�? */</span></span><br><span class="line">            xFreeBytesRemaining += pxLink-&gt;xBlockSize;</span><br><span class="line">            </span><br><span class="line">            traceFREE( pv, pxLink-&gt;xBlockSize );</span><br><span class="line">        &#125;</span><br><span class="line">        ( <span class="type">void</span> ) xTaskResumeAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img1.imgtp.com/2023/02/14/75udKUzD.png" alt="image-20230214194242383"></p><h3 id="获取未分配的内存堆大小xPortGetFreeHeapSize"><a href="#获取未分配的内存堆大小xPortGetFreeHeapSize" class="headerlink" title="获取未分配的内存堆大小xPortGetFreeHeapSize()"></a>获取未分配的内存堆大小xPortGetFreeHeapSize()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">xPortGetFreeHeapSize</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> xFreeBytesRemaining;<span class="comment">//它用来动态记录未分配的内存堆大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、heap-3-c"><a href="#3、heap-3-c" class="headerlink" title="3、heap_3.c"></a>3、heap_3.c</h2><p><strong>第三种内存管理策略简单的封装了标准库中的malloc()和free()函数，采用的封装方式是操作内存前挂起调度器、完成后再恢复调度器。封装后的malloc()和free()函数具备线程保护�?</strong>第一种和第二种内存管理策略都是通过定义一个大数组作为内存堆，数组的大小由宏configTOTAL_HEAP_SIZE指定。第三种内存管理策略与前两种不同，它不再需要通过数组定义内存堆，而是需要使用编译器设置内存堆空间，一般在启动代码中设置。因此宏configTOTAL_HEAP_SIZE对这种内存管理策略是无效的�?</p><h3 id="内存申请pvPortMalloc"><a href="#内存申请pvPortMalloc" class="headerlink" title="内存申请pvPortMalloc()"></a>内存申请pvPortMalloc()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">pvPortMalloc</span><span class="params">( <span class="type">size_t</span> xWantedSize )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span> *pvReturn;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    vTaskSuspendAll();</span><br><span class="line">    &#123;</span><br><span class="line">        pvReturn = <span class="built_in">malloc</span>( xWantedSize );</span><br><span class="line">        traceMALLOC( pvReturn, xWantedSize );</span><br><span class="line">    &#125;</span><br><span class="line">    ( <span class="type">void</span> ) xTaskResumeAll();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="meta">#<span class="keyword">if</span>( configUSE_MALLOC_FAILED_HOOK == 1 )</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( pvReturn == <span class="literal">NULL</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">vApplicationMallocFailedHook</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line">            vApplicationMallocFailedHook();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> pvReturn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内存释放"><a href="#内存释放" class="headerlink" title="内存释放"></a>内存释放</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vPortFree</span><span class="params">( <span class="type">void</span> *pv )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( pv )</span><br><span class="line">    &#123;</span><br><span class="line">        vTaskSuspendAll();</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">free</span>( pv );</span><br><span class="line">            traceFREE( pv, <span class="number">0</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        ( <span class="type">void</span> ) xTaskResumeAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、heap4-c"><a href="#4、heap4-c" class="headerlink" title="4、heap4.c"></a>4、heap4.c</h2><p>第四种内存分配方法与第二种比较相似，只不过增加了一个合并算法，将相邻的空闲内存块合并成一个大块。与第一种和第二种内存管理策略一样，内存堆仍然是一个大数组，定义为�?</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> ucHeap[ configTOTAL_HEAP_SIZE ];</span><br></pre></td></tr></table></figure><p>heap_4.c 方案的空闲内存块也是以单链表的形式连接起来的，BlockLink_t 类型的局部静态变�? xStart 表示链表头，�? heap_4.c 内存管理方案的链表尾部则保存在内存堆空间最后位置，并使�? BlockLink_t 指针类型局部静态变�? pxEnd 指向这个区域（�? heap_2.c 内存管理方案则使�? BlockLink_t 类型的静态变�? xEnd 表示链表尾）</p><p>heap_4.c 内存管理方案的空闲块链表不是以内存块大小进行排序的，而是<strong>以内存块起始地址大小排序</strong>，内存地址小的在前，地址大的在后，因�? heap_4.c 方案还有一个内存合并算法，在释放内存的时候，假如相邻的两个空闲内存块在地址上是连续的，那么就可以合并为一个内存块，这也是为了适应合并算法而作的改变�?</p><p><strong>heap_4.c 方案具有以下特点�?</strong></p><blockquote><ol><li>可用于重复删除任务、队列、信号量、互斥量等的应用程序</li><li>可用于分配和释放随机字节内存的应用程序，但并不像 heap2.c 那样产生严重的内存碎片�?</li><li>具有不确定性，但是效率比标�? C 库中�? malloc 函数高得多�?</li></ol></blockquote><h3 id="内存初始化函数prvHeapInit"><a href="#内存初始化函数prvHeapInit" class="headerlink" title="内存初始化函数prvHeapInit()"></a>内存初始化函数prvHeapInit()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">prvHeapInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    lockLink_t *pxFirstFreeBlock;</span><br><span class="line">    <span class="type">int8_t</span> *pucAlignedHeap;</span><br><span class="line">    <span class="type">size_t</span> uxAddress;</span><br><span class="line">    <span class="type">size_t</span> xTotalHeapSize = configTOTAL_HEAP_SIZE;</span><br><span class="line">    <span class="comment">/*进行内存对齐操作 */</span></span><br><span class="line">    xAddress = (<span class="type">size_t</span>)ucHeap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((uxAddress &amp; portBYTE_ALIGNMENT_MASK) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        uxAddress += (portBYTE_ALIGNMENT - <span class="number">1</span>);</span><br><span class="line">        uxAddress &amp;= ~((<span class="type">size_t</span>)portBYTE_ALIGNMENT_MASK);</span><br><span class="line">        <span class="comment">// xTotalHeapSize 表示系统管理的总内存大�?</span></span><br><span class="line">        xTotalHeapSize -= uxAddress - (<span class="type">size_t</span>)ucHeap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pucAlignedHeap = (<span class="type">uint8_t</span> *)uxAddress;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化链表头�?</span></span><br><span class="line">    xStart.pxNextFreeBlock = (<span class="type">void</span> *)pucAlignedHeap;</span><br><span class="line">    xStart.xBlockSize = (<span class="type">size_t</span>)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始�? pxEnd，计�? pxEnd 的位置，它的值为内存尾部向前偏移一�?</span></span><br><span class="line"><span class="comment">    BlockLink_t 结构体大小，偏移出来的这�? BlockLink_t 就是 pxEnd */</span></span><br><span class="line">    uxAddress = ((<span class="type">size_t</span>)pucAlignedHeap) + xTotalHeapSize;</span><br><span class="line">    uxAddress -= xHeapStructSize;</span><br><span class="line">    uxAddress &amp;= ~((<span class="type">size_t</span>)portBYTE_ALIGNMENT_MASK);</span><br><span class="line">    pxEnd = (<span class="type">void</span> *)uxAddress;</span><br><span class="line">    pxEnd-&gt;xBlockSize = <span class="number">0</span>;</span><br><span class="line">    pxEnd-&gt;pxNextFreeBlock = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* �? heap_2.c 中的初始化类似，将当前所有内存插入空闲内存块链表中�?</span></span><br><span class="line"><span class="comment">    不同的是链表的尾部不是静态的，而是放在了内存的最后�? */</span></span><br><span class="line">    pxFirstFreeBlock = (<span class="type">void</span> *)pucAlignedHeap;</span><br><span class="line">    pxFirstFreeBlock-&gt;xBlockSize = uxAddress - (<span class="type">size_t</span>)pxFirstFreeBlock;</span><br><span class="line">    pxFirstFreeBlock-&gt;pxNextFreeBlock = pxEnd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 更新统计变量 */</span></span><br><span class="line">    xMinimumEverFreeBytesRemaining = pxFirstFreeBlock-&gt;xBlockSize;</span><br><span class="line">    xFreeBytesRemaining = pxFirstFreeBlock-&gt;xBlockSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 这个 xBlockAllocatedBit 比较特殊，这里被设置为最高位�? 1 其余�? 0 �?</span></span><br><span class="line"><span class="comment">    一�? size_t 大小的值，这样任意一�? size_t 大小的值和 xBlockAllocatedBit</span></span><br><span class="line"><span class="comment">    进行按位与操�?,如果该值最高位�? 1，那么结果为 1，否则结果为 0�?</span></span><br><span class="line"><span class="comment">    FreeRTOS 利用这种特性标记一个内存块是否空闲�? */</span></span><br><span class="line">    xBlockAllocatedBit = ((<span class="type">size_t</span>)<span class="number">1</span>) &lt;&lt; ((<span class="keyword">sizeof</span>(<span class="type">size_t</span>) * heapBITS_PER_BYTE) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>heap_4.c 内存初始化完成示意图具体见图23-8�?</p><p><img src="https://img1.imgtp.com/2023/02/14/jEJ0bviL.png" alt="image-20230214202303646"></p><h3 id="内存块插入函�-prvInsertBlockIntoFreeList"><a href="#内存块插入函�-prvInsertBlockIntoFreeList" class="headerlink" title="内存块插入函�? prvInsertBlockIntoFreeList()"></a>内存块插入函�? prvInsertBlockIntoFreeList()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">prvInsertBlockIntoFreeList</span><span class="params">(BlockLink_t *pxBlockToInsert)</span></span><br><span class="line">&#123;</span><br><span class="line">    BlockLink_t *pxIterator;</span><br><span class="line">    <span class="type">uint8_t</span> *puc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 首先找到�? pxBlockToInsert 相邻的前一个空闲内�? */</span></span><br><span class="line">    <span class="keyword">for</span> (pxIterator = &amp;xStart;pxIterator-&gt;pxNextFreeBlock &lt; pxBlockToInsert;pxIterator = pxIterator-&gt;pxNextFreeBlock)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这里什么都不做,只为了找空闲内存而已</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    puc = (<span class="type">uint8_t</span> *)pxIterator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果前一个内存的尾部恰好�? pxBlockToInsert 的头部，</span></span><br><span class="line"><span class="comment">    那代表这两个内存是连续的，可以合�?*/</span></span><br><span class="line">    <span class="keyword">if</span> ((puc + pxIterator-&gt;xBlockSize) == (<span class="type">uint8_t</span> *)pxBlockToInsert)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* �? pxBlockToInsert 合并�? pxIterator �? */</span></span><br><span class="line">        pxIterator-&gt;xBlockSize += pxBlockToInsert-&gt;xBlockSize;</span><br><span class="line">        pxBlockToInsert = pxIterator;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断 pxBlockToInsert 是否和后面的空闲内存相邻 */</span></span><br><span class="line">    puc = (<span class="type">uint8_t</span> *)pxBlockToInsert;</span><br><span class="line">    <span class="keyword">if</span> ((puc + pxBlockToInsert-&gt;xBlockSize) ==(<span class="type">uint8_t</span> *)pxIterator-&gt;pxNextFreeBlock)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="comment">/* 与之相邻的下一个内存块不是链表尾节�? */</span></span><br><span class="line">        <span class="keyword">if</span> (pxIterator-&gt;pxNextFreeBlock != pxEnd)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 将后面的内存合入 pxBlockToInsert，并�? pxBlockToInsert 代替该内存在链表中的位置 */</span></span><br><span class="line">            pxBlockToInsert-&gt;xBlockSize += pxIterator-&gt;pxNextFreeBlock-&gt;xBlockSize;</span><br><span class="line">            pxBlockToInsert-&gt;pxNextFreeBlock = pxIterator-&gt;pxNextFreeBlock-&gt;pxNextFreeBlock;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pxBlockToInsert-&gt;pxNextFreeBlock = pxEnd;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 后面不相邻，那么只能插入链表�?</span></span><br><span class="line">        pxBlockToInsert-&gt;pxNextFreeBlock = pxIterator-&gt;pxNextFreeBlock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断下前面是否已经合并了，如果合并了，就不用再更新链表了 */</span></span><br><span class="line">    <span class="keyword">if</span> (pxIterator != pxBlockToInsert)</span><br><span class="line">    &#123;</span><br><span class="line">        pxIterator-&gt;pxNextFreeBlock = pxBlockToInsert;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个合并的算法常用于释放内存的合并，申请内存的时候能合并的早已合并，因为申请内存是从一个空闲内存块前面分割，分割后产生的内存块都是一整块的，基本不会进行合并，申请内存常见的情况具体见图23-9�?</p><p><img src="https://img1.imgtp.com/2023/02/14/eKUtYPnn.png" alt="image-20230214203159531"></p><h3 id="内存申请函数-pvPortMalloc"><a href="#内存申请函数-pvPortMalloc" class="headerlink" title="内存申请函数 pvPortMalloc()"></a>内存申请函数 pvPortMalloc()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">pvPortMalloc</span><span class="params">( <span class="type">size_t</span> xWantedSize )</span></span><br><span class="line">&#123;</span><br><span class="line">BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;</span><br><span class="line"><span class="type">void</span> *pvReturn = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">vTaskSuspendAll();</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 如果是第一次调用内存分配函数，先初始化内存�? */</span></span><br><span class="line"><span class="keyword">if</span> ( pxEnd == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">prvHeapInit();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">mtCOVERAGE_TEST_MARKER();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/* 这里 xWantedSize 的大小有要求，需要最高位�? 0。因为后�? BlockLink_t 结构体中�? xBlockSize 的最高位需要使用这个成员的最高位被用来标识这个块是否空闲。因此要申请的块大小不能使用这个�?*/</span></span><br><span class="line">    <span class="keyword">if</span> ( ( xWantedSize &amp; xBlockAllocatedBit ) == <span class="number">0</span> ) &#123;</span><br><span class="line">    <span class="comment">/* 调整要分配的内存值，需要增加上链表结构体所占的内存空间heapSTRUCT_SIZE 表示链表结构体节点经过内存对齐后的内存大小因为空余内存的头部要放一�? BlockLink_t 类型的节点来管理，因此这里需要人为的扩充下申请的内存大小 */</span></span><br><span class="line">        <span class="keyword">if</span> ( xWantedSize &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">            xWantedSize += xHeapStructSize;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 需要申请的内存大小与系统要求对齐的字节数不匹配，需要进行内存对�? */</span></span><br><span class="line">            <span class="keyword">if</span> ( ( xWantedSize &amp; portBYTE_ALIGNMENT_MASK ) != <span class="number">0x00</span> ) &#123;</span><br><span class="line">                xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize &amp; portBYTE_ALIGNMENT_MASK ) );</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果当前的空闲内存足够满足用户申请的内存大小，就进行内存申请操作</span></span><br><span class="line">    <span class="keyword">if</span> ( ( xWantedSize &gt; <span class="number">0</span> ) &amp;&amp; ( xWantedSize &lt;= xFreeBytesRemaining ) ) &#123;</span><br><span class="line">    <span class="comment">/* 从空余内存链表的头部开始找，如果该空余内存的大�?&gt;xWantedSize，就从这块内存中抠出一部分内存返回，剩余的内存生成新的 BlockLink_t 插入链表�?*/</span></span><br><span class="line">            pxPreviousBlock = &amp;xStart;</span><br><span class="line">            pxBlock = xStart.pxNextFreeBlock;</span><br><span class="line">            <span class="comment">//从链表头部开始查找大小符合条件的空余内存</span></span><br><span class="line">            <span class="keyword">while</span> ( ( pxBlock-&gt;xBlockSize &lt; xWantedSize )&amp;&amp; ( pxBlock-&gt;pxNextFreeBlock != <span class="literal">NULL</span> ) ) &#123;</span><br><span class="line">                pxPreviousBlock = pxBlock;</span><br><span class="line">                pxBlock = pxBlock-&gt;pxNextFreeBlock;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* 如果搜索到链表尾 xEnd，说明没有找到合适的空闲内存块，否则进行下一步处�?*/</span></span><br><span class="line"><span class="keyword">if</span> ( pxBlock != pxEnd ) &#123;</span><br><span class="line">       <span class="comment">/* 能执行到这里，说明已经找到合适的内存块了，找到内存块，就返回内存块地址，注意了：这里返回的是内存块 +内存块链表结构体空间的偏移地址，因为内存块头部需要有一个空闲链表节�?*/</span></span><br><span class="line">pvReturn = ( <span class="type">void</span> * ) ( ( ( <span class="type">uint8_t</span> * ) pxPreviousBlock-&gt;pxNextFreeBlock ) + xHeapStructSize );</span><br><span class="line"><span class="comment">//* 因为这个内存块被用户使用了，需要从空闲内存块链表中移除 */</span></span><br><span class="line">pxPreviousBlock-&gt;pxNextFreeBlock = pxBlock-&gt;pxNextFreeBlock;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*再看看这个内存块的内存空间够不够多，能不能分成两个，申请的内存块就给用户，剩下的内存就留出来，放到空闲内存块链表中作为下一次内存块申请�? */</span></span><br><span class="line"><span class="keyword">if</span>((pxBlock-&gt;xBlockSize - xWantedSize ) &gt; heapMINIMUM_BLOCK_SIZE ) &#123;</span><br><span class="line"><span class="comment">/* 去除分配出去的内存，在剩余内存块的起始位置放置一个链表节�?*/</span></span><br><span class="line">pxNewBlockLink = ( <span class="type">void</span> * ) ( ( ( <span class="type">uint8_t</span> * ) pxBlock ) + xWantedSize );</span><br><span class="line">                configASSERT( ( ( ( <span class="type">size_t</span> ) pxNewBlockLink ) &amp; portBYTE_ALIGNMENT_MASK ) == <span class="number">0</span> );</span><br><span class="line"><span class="comment">/* 通过计算得到剩余的内存大小，并且赋值给剩余内存块链表节点中�? xBlockSize 成员变量，方便下一次的内存查找 */</span></span><br><span class="line">pxNewBlockLink-&gt;xBlockSize = pxBlock-&gt;xBlockSize - xWantedSize;</span><br><span class="line">pxBlock-&gt;xBlockSize = xWantedSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将被切割而产生的新空闲内存块添加到空闲链表中 */</span></span><br><span class="line">prvInsertBlockIntoFreeList( pxNewBlockLink ); </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">mtCOVERAGE_TEST_MARKER();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//更新剩余内存总大�?</span></span><br><span class="line">            xFreeBytesRemaining -= pxBlock-&gt;xBlockSize;</span><br><span class="line">            <span class="comment">//如果当前内存大小小于历史最小记录，更新历史最小内存记�?</span></span><br><span class="line">            <span class="keyword">if</span> ( xFreeBytesRemaining &lt; xMinimumEverFreeBytesRemaining ) &#123;</span><br><span class="line">           xMinimumEverFreeBytesRemaining = xFreeBytesRemaining; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">/* 注意这里�? xBlockSize 的最高位被设置为 1，标记内存已经被申请使用*/</span></span><br><span class="line">            pxBlock-&gt;xBlockSize |= xBlockAllocatedBit;</span><br><span class="line">            pxBlock-&gt;pxNextFreeBlock = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       mtCOVERAGE_TEST_MARKER();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">mtCOVERAGE_TEST_MARKER();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">traceMALLOC( pvReturn, xWantedSize );</span><br><span class="line">&#125;</span><br><span class="line">( <span class="type">void</span> ) xTaskResumeAll();</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span>( configUSE_MALLOC_FAILED_HOOK == 1 )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ( pvReturn == <span class="literal">NULL</span> ) &#123;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">vApplicationMallocFailedHook</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line">vApplicationMallocFailedHook();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">mtCOVERAGE_TEST_MARKER();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">     <span class="keyword">return</span> pvReturn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存申请函数，在申请 3 次内存完成之后的示意图具体见�? 23-10�?</p><p><img src="https://img1.imgtp.com/2023/02/14/ga9KfDIL.png" alt="image-20230214203317335"></p><h3 id="内存释放函数vPortFree"><a href="#内存释放函数vPortFree" class="headerlink" title="内存释放函数vPortFree()"></a>内存释放函数vPortFree()</h3><p>heap_4.c 内存管理方案的内存释放函�? vPortFree()也比较简单，根据传入要释放的内存块地址，偏移之后找到链表节点，然后将这个内存块插入到空闲内存块链表中，在内存块插入过程中会执行合并算法，这个我们已经在内存申请中讲过了（而且合并算法多用于释放内存中）。最后是将这个内存块标志为“空闲”（内存块节点的 xBlockSize 成员变量最高位�? 0）、再更新未分配的内存堆大小即可�?</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vPortFree</span><span class="params">(<span class="type">void</span> *pv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> *puc = (<span class="type">uint8_t</span> *)pv;</span><br><span class="line">    BlockLink_t *pxLink;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pv != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 偏移得到节点地址 */</span></span><br><span class="line">        puc -= xHeapStructSize;</span><br><span class="line">        pxLink = (<span class="type">void</span> *)puc;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 断言 */</span></span><br><span class="line">        configASSERT((pxLink-&gt;xBlockSize &amp; xBlockAllocatedBit) != <span class="number">0</span>);</span><br><span class="line">        configASSERT(pxLink-&gt;pxNextFreeBlock == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 判断一下内存块是否已经是被分配使用的，如果是就释放该内存块 */</span></span><br><span class="line">        <span class="keyword">if</span> ((pxLink-&gt;xBlockSize &amp; xBlockAllocatedBit) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pxLink-&gt;pxNextFreeBlock == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* 将内存块标识为空�? */</span></span><br><span class="line">                pxLink-&gt;xBlockSize &amp;= ~xBlockAllocatedBit;</span><br><span class="line">                vTaskSuspendAll();</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* 更新系统当前空闲内存的大小，添加到内存块空闲链表�? */</span></span><br><span class="line">                    xFreeBytesRemaining += pxLink-&gt;xBlockSize;</span><br><span class="line">                    traceFREE(pv, pxLink-&gt;xBlockSize);</span><br><span class="line">                    prvInsertBlockIntoFreeList(((BlockLink_t *)pxLink));</span><br><span class="line">                &#125;</span><br><span class="line">                (<span class="type">void</span>)xTaskResumeAll();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照内存释放的过程，当我们释放一个内存时，如果与它相邻的内存块都不是空闲的，那么该内存块并不会合并，只会被添加到空闲内存块链表中，其过程示意图具体见�?23-11。而如果某个时间段释放了另一个内存块，发现该内存块前面有一个空闲内存块与它在地址上是连续的，那么这两个内存块会合并成一个大的内存块，并插入空闲内存块链表中，其过程示意图具体见�? 23-12�?</p><p><img src="https://img1.imgtp.com/2023/02/14/0pXlDeFj.png" alt="image-20230214203903557"></p><p><img src="https://img1.imgtp.com/2023/02/14/LG0665Qq.png" alt="image-20230214203849508"></p><h2 id="5、heap-5-c"><a href="#5、heap-5-c" class="headerlink" title="5、heap_5.c"></a>5、heap_5.c</h2><p>heap_5.c 方案在实现动态内存分配时�? heap4.c 方案一样，采用最佳匹配算法和合并算法，并且允许内存堆跨越多个非连续的内存区，也就是允许在不连续的内存堆中实现内存分配，比如用户在片内 RAM 中定义一个内存堆，还可以在外�? SDRAM 再定义一个或多个内存堆，这些内存都归系统管理�?</p><p>heap_5.c 方案通过调用 vPortDefineHeapRegions()函数来实现系统管理的内存初始化，在内存初始化未完成前不允许使用内存分配和释放函数。如创建 FreeRTOS 对象（任务、队列、信号量等）时会隐式的调�? pvPortMalloc()函数，因此必须注意：使用 heap_5.c 内存管理方案创建任何对象前，要先调用 vPortDefineHeapRegions()函数将内存初始化�?</p><p>vPortDefineHeapRegions()函数只有一个形参，该形参是一�? HeapRegion_t 类型的结构体数组。HeapRegion_t 类型结构体在 portable.h 中定义，具体见代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeapRegion</span> &#123;</span></span><br><span class="line"><span class="comment">/* 用于内存堆的内存块起始地址*/</span></span><br><span class="line"><span class="type">uint8_t</span> *pucStartAddress;</span><br><span class="line">    <span class="comment">/* 内存块大�? */</span></span><br><span class="line">    <span class="type">size_t</span> xSizeInBytes;</span><br><span class="line">&#125; HeapRegion_t;</span><br></pre></td></tr></table></figure><p>�? �? 需 要指 定每 �? 内存 �? 区域 的起 �? 地址 �? 内存 堆大 �? 、将 �? 们放 在一 个HeapRegion_t 结构体类型数组中，这个数组必须用一�? NULL 指针�? 0 作为结尾，起始地址必须从小到大排列。假设我们为内存堆分配两个内存块，第一个内存块大小�? 0x10000字节，起始地址�? 0x80000000；第二个内存块大小为 0xa0000 字节，起始地址�?0x90000000，vPortDefineHeapRegions()函数使用实例具体见代�?:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在内存中为内存堆分配两个内存块�?</span></span><br><span class="line"><span class="comment">第一个内存块大小�? 0x10000 字节,起始地址�? 0x80000000,</span></span><br><span class="line"><span class="comment">第二个内存块大小�? 0xa0000 字节,起始地址�? 0x90000000�?</span></span><br><span class="line"><span class="comment">起始地址�? 0x80000000 的内存块的起始地址更低,因此放到了数组的第一个位置�?*/</span></span><br><span class="line"><span class="type">const</span> HeapRegion_t xHeapRegions[] = &#123;</span><br><span class="line">&#123; ( <span class="type">uint8_t</span> * ) <span class="number">0x80000000</span>UL, <span class="number">0x10000</span> &#125;,</span><br><span class="line">&#123; ( <span class="type">uint8_t</span> * ) <span class="number">0x90000000</span>UL, <span class="number">0xa0000</span> &#125;,</span><br><span class="line">&#123; <span class="literal">NULL</span>, <span class="number">0</span> &#125; <span class="comment">/* 数组结尾 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 向函�? vPortDefineHeapRegions()传递形�? */</span></span><br><span class="line">vPortDefineHeapRegions( xHeapRegions );</span><br></pre></td></tr></table></figure><p>用户在自定义好内存堆数组后，需要调�? vPortDefineHeapRegions()函数初始化这些内存堆，系统会已一个空闲内存块链表的数据结构记录这些空闲内存，链表�? xStart 节点构开头，�? pxEnd 指针指向的位置结束。vPortDefineHeapRegions()函数对内存的初始�?<strong>与heap_4.c 方案一�?</strong>，在这里就不再重复赘述过程。以上面的内存堆数组为例，初始化完成后的内存堆示意图:</p><p><img src="https://img1.imgtp.com/2023/02/14/gbhiMr3T.png" alt="image-20230214204419906"></p><h1 id="三、参考文�"><a href="#三、参考文�" class="headerlink" title="三、参考文�?"></a>三、参考文�?</h1><p><a href="http://www.firebbs.cn/">野火电子论坛</a></p><p><a href="https://blog.csdn.net/zhzht19861011/article/details/51606068"> FreeRTOS高级�?7—-FreeRTOS内存管理分析</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreeRTOS(一)</title>
      <link href="/2023/02/13/freertos01/"/>
      <url>/2023/02/13/freertos01/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PID算法(一)</title>
      <link href="/2023/02/13/pid01/"/>
      <url>/2023/02/13/pid01/</url>
      
        <content type="html"><![CDATA[<h1 id="1、PID的概念"><a href="#1、PID的概念" class="headerlink" title="1、PID的概念"></a>1、PID的概念</h1><p>PID算法是工业应用中最广泛算法之一，在闭环系统的控制中，可自动对控制系统进行准确且迅速的校正。PID算法已经有100多年历史，在四轴飞行器，平衡小车、汽车定速巡航、温度控制器等场景均有应用。</p><p><strong>PID算法：就是“比例（proportional）、积分（integral）、微分（derivative）”，是一种常见的“保持稳定”控制算法。</strong></p><p>常规的模拟PID控制系统原理框图如下所示:</p><p><img src="https://cdn.staticaly.com/gh/QM1412/blog_bed@main/img/image-20230213101736869.png" alt="image-20230213101736869"></p><p>因此可以得出e(t)和u(t)的关系：</p><p><img src="https://cdn.staticaly.com/gh/QM1412/blog_bed@main/img/image-20230213101801907.png" alt="image-20230213101801907"></p><p>其中：</p><ul><li><p>Kp：比例增益，是调适参数；</p></li><li><p>Ki：积分增益，也是调适参数；</p></li><li><p>Kd：微分增益，也是调适参数；</p></li><li><p>e：误差=设定值（SP）- 回授值（PV）；</p></li><li><p>t：目前时间。</p></li></ul><p>数学公式可能比较枯燥，通过以下例子，了解PID算法的应用。</p><p>例如，使用控制器使一锅水的温度保持在50℃，小于50℃就让它加热，大于50度就断电不就行了？</p><p><img src="https://cdn.staticaly.com/gh/QM1412/blog_bed@main/img/image-20230213102008694.png" alt="image-20230213102008694"></p><p>假如要求不搞的情况下可以这么做，但是要维持在50°C就比较困难，正如图中小人一样，只有低于50才加热，高于50就断开，那么温度就会在50上下来回震荡，很难接近50使之稳定。</p><p>设想一下，假如汽车的定速巡航电脑在某一时间测到车速是45km/h，它立刻命令发动机：加速！</p><p>结果，发动机那边突然来了个100%全油门，嗡的一下汽车急加速到了60km/h，这时电脑又发出命令：刹车！结果乘客吐……</p><p>所以，在大多数场合中，用“开关量”来控制一个物理量就显得比较简单粗暴了，有时候是无法保持稳定的，因为单片机、传感器不是无限快的，采集、控制需要时间。</p><p><img src="https://cdn.staticaly.com/gh/QM1412/blog_bed@main/img/image-20230213102443083.png" alt="image-20230213102443083"></p><p><strong>（1）Kp比例增益</strong></p><p>Kp比例控制考虑当前误差，误差值和一个正值的常数Kp（表示比例）相乘。需要控制的量，比如水温，有它现在的<strong>当前值</strong>，也有我们期望的<strong>目标值</strong>。</p><ul><li><p>当两者差距不大时，就让加热器“轻轻地”加热一下。</p></li><li><p>要是因为某些原因，温度降低了很多，就让加热器“稍稍用力”加热一下。</p></li><li><p>要是当前温度比目标温度低得多，就让加热器“开足马力”加热，尽快让水温到达目标附近。</p></li></ul><p>通俗的来讲就是P就是响应速度，例如，当烧水的时候，一开始是20℃，要加热到90℃，这个时候误差e=70℃，那么就要加大火力去让温度上升，当温度到达65℃，误差e=5℃，这个时候就不用这么大火力去烧水。</p><p>实际写程序时，就让偏差（目标减去当前）与调节装置的“调节力度”，建立一个一次函数的关系，就可以实现最基本的“比例”控制了~</p><p>Kp越大，调节作用越激进，Kp调小会让调节作用更保守。</p><p>但是，这个也有缺点，若只用“比例控制”的话，那么就无时无刻都会有误差，当e=0的时候，系统就不再控制了，这样整个系统就会来回震荡。若你正在制作一个平衡车，有了P的作用，你会发现，平衡车在平衡角度附近来回“狂抖”，比较难稳住。</p><p><strong>（2）Kd微分增益</strong></p><p>Kd微分控制考虑将来误差，计算误差的一阶导，并和一个正值的常数Kd相乘。（看的是趋势，也就是<strong>误差之差</strong>）</p><p>有了P的作用，不难发现，只有P好像不能让平衡车站起来，水温也控制得晃晃悠悠，好像整个系统不是特别稳定，总是在“抖动”。</p><p><img src="https://cdn.staticaly.com/gh/QM1412/blog_bed@main/img/image-20230213104225103.png" alt="image-20230213104225103"></p><p>设想有一个弹簧：现在在平衡位置上，拉它一下，然后松手，这时它会震荡起来，因为阻力很小，它可能会震荡很长时间，才会重新停在平衡位置。</p><p>请想象一下：要是把上图所示的系统浸没在水里，同样拉它一下 ：这种情况下，重新停在平衡位置的时间就短得多。</p><p>此时需要一个控制作用，让被控制的物理量的“变化速度”趋于0，即类似于“阻尼”的作用。</p><p>因为，当比较接近目标时，P的控制作用就比较小了，越接近目标，P的作用越温柔，有很多内在的或者外部的因素，使控制量发生小范围的摆动。</p><p>D的作用就是让物理量的速度趋于0，只要什么时候，这个量具有了速度，D就向相反的方向用力，尽力刹住这个变化。</p><p>Kd参数越大，向速度相反方向刹车的力道就越强，如果是平衡小车，加上P和D两种控制作用，如果参数调节合适，它应该可以站起来了。<br><strong>（3）Ki积分增益</strong></p><p>Ki积分控制考虑过去误差，将误差值过去一段时间和（误差和）乘以一个正值的常数Ki。</p><p>还是以热水为例，假如有个人把加热装置带到了非常冷的地方，开始烧水了，需要烧到50℃。</p><p>在P的作用下，水温慢慢升高，直到升高到45℃时，他发现了一个不好的事情：天气太冷，水散热的速度，和P控制的加热的速度相等了。</p><p><strong>这可怎么办？</strong></p><ul><li><p>P兄这样想：我和目标已经很近了，只需要轻轻加热就可以了。</p></li><li><p>D兄这样想：加热和散热相等，温度没有波动，我好像不用调整什么。</p></li><li><p>于是，水温永远地停留在45℃，永远到不了50℃。</p></li></ul><p>根据常识，我们知道，应该进一步增加加热的功率，可是增加多少该如何计算呢？</p><p>前辈科学家们想到的方法是真的巧妙，设置一个积分量，只要偏差存在，就不断地对偏差进行积分（累加），并反应在调节力度上。</p><p>这样一来，即使45℃和50℃相差不是太大，但是随着时间的推移，只要没达到目标温度，这个积分量就不断增加，系统就会慢慢意识到：还没有到达目标温度，该增加功率啦！</p><p>到了目标温度后，假设温度没有波动，积分值就不会再变动，这时，加热功率仍然等于散热功率，但是，温度是稳稳的50℃。</p><p>Ki的值越大，积分时乘的系数就越大，积分效果越明显，所以，I的作用就是，减小静态情况下的误差，让受控物理量尽可能接近目标值。</p><p><strong>I在使用时还有个问题：需要设定积分限制，防止在刚开始加热时，就把积分量积得太大，难以控制。</strong></p><h1 id="2、PID算法参数调试"><a href="#2、PID算法参数调试" class="headerlink" title="2、PID算法参数调试"></a>2、PID算法参数调试</h1><p>PID算法的参数调试是指通过调整控制参数（比例增益、积分增益/时间、微分增益/时间）<strong>让系统达到最佳的控制效果</strong>。</p><p>调试中稳定性（不会有发散性的震荡）是首要条件，此外，不同系统有不同的行为，不同的应用其需求也不同，而且这些需求还可能会互相冲突。</p><p><a href="https://rossning92.github.io/pid-simulation/">可以通过这个自己动手调节一下，看看结果如何🐧</a></p><p><img src="https://cdn.staticaly.com/gh/QM1412/blog_bed@main/img/image-20230213105127774.png" alt="image-20230213105127774"></p><p>PID算法只有三个参数，在原理上容易说明，但PID算法参数调试是一个困难的工作，因为要符合一些特别的判据，而且PID控制有其限制存在。</p><p><strong>1、稳定性</strong></p><p>若PID算法控制器的参数未挑选妥当，其控制器输出可能是不稳定的，也就是其输出发散，过程中可能有震荡，也可能没有震荡，且其输出只受饱和或是机械损坏等原因所限制。不稳定一般是因为过大增益造成，特别是针对延迟时间很长的系统。</p><p>2、最佳性能</p><p>PID控制器的最佳性能可能和针对过程变化或是设定值变化有关，也会随应用而不同。</p><p>两个基本的需求是调整能力（regulation，干扰拒绝，使系统维持在设定值）及命令追随 （设定值变化下，控制器输出追随设定值的反应速度）。有关命令追随的一些判据包括有上升时间及整定时间。有些应用可能因为安全考量，不允许输出超过设定值，也有些应用要求在到达设定值过程中的能量可以最小化。</p><p><strong>3、各调试方法对比</strong></p><p><img src="https://cdn.staticaly.com/gh/QM1412/blog_bed@main/img/image-20230213105526182.png" alt="image-20230213105526182"></p><p><strong>4、调整PID参数对系统的影响</strong> </p><p><img src="https://cdn.staticaly.com/gh/QM1412/blog_bed@main/img/image-20230213105552097.png" alt="image-20230213105552097"></p><p><strong>参考资料：</strong></p><p><a href="https://blog.csdn.net/m0_38106923/article/details/109545445?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=pid&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-109545445.142^v73^insert_down2,201^v4^add_ask,239^v1^control&amp;spm=1018.2226.3001.4187"> 一文搞懂PID控制算法</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI4MDI4MDE5Ng==&amp;mid=2247488157&amp;idx=2&amp;sn=3b214c5ee27da1a0075b51d886b9f580&amp;chksm=ebbbbf76dccc36603e441e89aca2f61ad22858c49756e51c601d213acd4778c1ff5b2b56fb0f&amp;scene=21#wechat_redirect">PID原理和参数调试</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI4MDA2OTM4MA==&amp;mid=2459414238&amp;idx=1&amp;sn=82feaac579b491942e487c2e0622d5c9&amp;chksm=fcdd1ab5cbaa93a3d14f96c221cc6883f113c4954f40fd34284eae8cec1cc893d6d482f3c91f&amp;mpshare=1&amp;scene=1&amp;srcid=0924twXOIV8SKMcwY97lY428&amp;sharer_sharetime=1600949251548&amp;sharer_shareid=4c58b3600d67a71ab64a1eeb5ac2a392&amp;key=6de1ce3c70b324a40741efe7e69941de25bb83453933cba79214d7f9d0c3e7abe41ac09f158ce2d42ddfe68d2f092a502ddec3f9634d7ca431a9c752b49846e6b54d4c3f516389f7fc0517e5a70da30396d98774a5b367d067d5622975378dbcbd9bf2cdd993f9c95452e721690a0e80d12b426b5f2186a5bf9ff971a551917d&amp;ascene=1&amp;uin=MTg5Mzg2MjgyOA%3D%3D&amp;devicetype=Windows+10+x64&amp;version=6300002f&amp;lang=zh_CN&amp;exportkey=Aejrx9ckEPq6didl4xP09gA%3D&amp;pass_ticket=d7pYWgu6Wqd0XTmEgAxex08gu2s%2Fz09DL17Lrry7UfvPpjphxapcAp4zmziElkpo&amp;wx_header=0">谁曾想，听了个故事秒懂了PID！</a></p>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小屏幕</title>
      <link href="/2023/01/28/xiaopinmu/"/>
      <url>/2023/01/28/xiaopinmu/</url>
      
        <content type="html"><![CDATA[<h1 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h1><h2 id="1-成品演示"><a href="#1-成品演示" class="headerlink" title="1.成品演示"></a>1.成品演示</h2><p><table rules="none" align="center">    <tr>        <td>            <center>                <img src="https://cdn.staticaly.com/gh/QM1412/blog_bed@main/img/微信图片_20230128202820.jpg" width="60%" />                <br/>            </center>        </td>        <td>            <center>                <img src="https://cdn.staticaly.com/gh/QM1412/blog_bed@main/img/微信图片_20230128202807.jpg" width="60%" />                <br/>            </center>        </td>    </tr></table><br>这个项目是我第一个小项目，虽然是跟着人家的视频做的，但是从中还是学到了很多关于嵌入式的知识，我觉得这个项目还是很适合大多数人学单片机的第一个项目，虽然有些点我还是不了解，但是可以了解一个产品的框架以及流程。</p><p><strong>我的板子资料：</strong><a href="https://pan.baidu.com/s/1waibSlIEahSa8gyVcN39Xw">https://pan.baidu.com/s/1waibSlIEahSa8gyVcN39Xw</a>  提取码：3umi</p><h2 id="2-流程图"><a href="#2-流程图" class="headerlink" title="2.流程图"></a>2.流程图</h2><p><img src="https://cdn.staticaly.com/gh/QM1412/blog_bed@main/img/image-20230206182324735.png" alt="image-20230206182324735"></p><h2 id="3-建议"><a href="#3-建议" class="headerlink" title="3.建议"></a>3.建议</h2><ul><li>假如是第一次接触，可以试着模仿，代码看不懂没关系，能做出来自己不就满意了嘛(最后烧录用固件烧录就好)。</li><li>有一定的基础的话跟我一样从画板子-&gt;ESP32学习-&gt;源代码-&gt;自己修改-&gt;自我总结。</li><li>这个项目就当是自己的一个起点（毕竟我自己也不是很厉害那种😅😅）。</li></ul><h1 id="二、-立创EDA的导入以及打板操作"><a href="#二、-立创EDA的导入以及打板操作" class="headerlink" title="二、 立创EDA的导入以及打板操作"></a>二、 立创EDA的导入以及打板操作</h1><h2 id="1-立创EDA导入文件"><a href="#1-立创EDA导入文件" class="headerlink" title="1.立创EDA导入文件"></a>1.立创EDA导入文件</h2><p><img src="https://cdn.staticaly.com/gh/QM1412/blog_bed@main/img/image-20230128194836649.png" alt="image-20230128194836649"></p><p>   然后选择工程文件导入即可</p><ul><li><strong>原理图</strong></li></ul><p><img src="https://cdn.staticaly.com/gh/QM1412/blog_bed@main/img/image-20230128194951090.png" alt="image-20230128194951090"></p><ul><li><strong>PCB板图</strong></li></ul><p><img src="https://cdn.staticaly.com/gh/QM1412/blog_bed@main/img/pcb.jpg" alt="pcb"></p><ul><li><strong>Gerber文件导出</strong></li></ul><p><img src="https://cdn.staticaly.com/gh/QM1412/blog_bed@main/img/image-20230128195740939.png" alt="image-20230128195740939"></p><h2 id="2-板子打印的操作"><a href="#2-板子打印的操作" class="headerlink" title="2.板子打印的操作"></a>2.板子打印的操作</h2><p>（1）打板下单的操作（下载嘉立创下单助手）</p><p><img src="https://cdn.staticaly.com/gh/QM1412/blog_bed@main/img/image-20230128195647688.png" alt="image-20230128195647688"></p><p><img src="https://cdn.staticaly.com/gh/QM1412/blog_bed@main/img/image-20230128195913841.png" alt="image-20230128195913841"></p><p><img src="https://cdn.staticaly.com/gh/QM1412/blog_bed@main/img/image-20230128200109097.png" alt="image-20230128200109097"></p><p><img src="https://cdn.staticaly.com/gh/QM1412/blog_bed@main/img/image-20230206172412070.png" alt="image-20230206172412070"></p><p><img src="https://cdn.staticaly.com/gh/QM1412/blog_bed@main/img/image-20230206172530618.png" alt="image-20230206172530618"></p><p><img src="https://cdn.staticaly.com/gh/QM1412/blog_bed@main/img/image-20230206172630694.png" alt="image-20230206172630694"></p><p><img src="https://cdn.staticaly.com/gh/QM1412/blog_bed@main/img/image-20230206172904197.png" alt="image-20230206172904197"></p><h2 id="3、焊接工作"><a href="#3、焊接工作" class="headerlink" title="3、焊接工作"></a>3、焊接工作</h2><p>如果使用SMT加工的话可以直接烧录程序使用了</p><blockquote><ol><li><p>要根据boom表买相应的材料，然后还要有相应的焊接工具，比如,烙铁，松香，锡膏，长拆焊台等</p><p>（1）电烙铁（刀头），焊锡膏，焊锡，拆焊台</p><p>（2）助焊剂，一个夹板子的支架</p></li><li><p>屏幕，外壳，电池的购买链接：<a href="https://m.tb.cn/h.Um3oCwv?tk=YVEZd66OTfK">https://m.tb.cn/h.Um3oCwv?tk=YVEZd66OTfK</a></p></li><li><p>根据PCB安装贴片安装</p></li><li><p>测试部分，用电表测试有没有短路或者虚焊的地方（这里花了我好长时间，主要是座子那个部分，最好使用刀头电烙铁😶‍🌫️）</p></li><li><p>插上电，led能亮，没有发热的地方，初步断定没问题了</p></li><li><p>之后就是愉快的烧录时间啦</p></li></ol></blockquote><h1 id="三、烧录程序"><a href="#三、烧录程序" class="headerlink" title="三、烧录程序"></a>三、烧录程序</h1><h2 id="1-烧录工具下载"><a href="#1-烧录工具下载" class="headerlink" title="1. 烧录工具下载"></a>1. 烧录工具下载</h2><p><a href="https://www.espressif.com.cn/zh-hans/support/download/other-tools">工具 | 乐鑫科技</a></p><p><a href="https://pan.baidu.com/s/1waibSlIEahSa8gyVcN39Xw">烧录工具</a></p><h2 id="2-固件下载"><a href="#2-固件下载" class="headerlink" title="2.固件下载"></a>2.固件下载</h2><p><a href="https://pan.baidu.com/s/1waibSlIEahSa8gyVcN39Xw">固件资料</a></p><p><img src="https://cdn.staticaly.com/gh/QM1412/blog_bed@main/img/image-20230206183051551.png" alt="image-20230206183051551"></p><p><strong>bootloader.bin 引导加载</strong></p><p><strong>partition-table.bin 分区表</strong></p><p><strong>DesktopScreen.bin 应用固件</strong></p><p><strong>DesktopScreenFont.bin 字体库</strong></p><h2 id="3-固件烧录"><a href="#3-固件烧录" class="headerlink" title="3. 固件烧录"></a>3. 固件烧录</h2><p><strong>1、把板卡与电脑通过USB连接，打开设备管理器，记住端口填到第三步的COM中</strong></p><p><img src="https://cdn.staticaly.com/gh/QM1412/blog_bed@main/img/beijing.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/QM1412/blog_bed@main/img/image-20230206175451766.png" alt="image-20230206175451766"></p><p><strong>2、打开ESP FLASH TOOL，选择ESP32</strong></p><p><img src="https://cdn.staticaly.com/gh/QM1412/blog_bed@main/img/output1.png" alt=""></p><p><strong>3、选择固件和对应的烧录地址，配置烧录参数</strong></p><p>需配置晶振频率、SPI SPEED、SPI MODE、Flash Size、串口端口号和波特率等，此处波特率可以尽量选大一些（选择230400或460800），以节省时间，<code>若提示ERROR，请降低波特率</code>：</p><p><img src="https://cdn.staticaly.com/gh/QM1412/blog_bed@main/img/image-20230206175848618.png" alt="image-20230206175848618"></p><p><strong>注意：</strong></p><p><strong><code>1、注意下载固件前面的√要选上</code></strong></p><p><strong><code>2、下载前把电池和USB都接上</code></strong></p><h1 id="四、烧录以及常见错误"><a href="#四、烧录以及常见错误" class="headerlink" title="四、烧录以及常见错误"></a>四、烧录以及常见错误</h1><blockquote><p>1、频繁重启，屏幕一直闪烁，报Brownout detector was triggered<br>电源问题，需接上电池</p><p>2、报i2c相关错误<br>i2c_master_write_slave error<br>i2c_master_set_addr error<br>i2c是TP接口，报此问题一般是TP没接或者TP端子没焊接好</p><p>3、注意V3版本和V4版本板卡原理图不一样<br>V1.0.1-V1.0.3 是温湿度传感器版本（已不再维护，建议不要使用）<br>V1.0.4 是蜂鸣器版本</p><p>4、W (676) SPIFFS: mount failed, -10025. formatting…卡住<br>新的芯片首次烧录是会自动格式化文件系统，等待10s-30s，格式化完成后会自动重启。</p><p>5、打印 DS_UI_PAGE_MANAGE: now_show_page 0 ui_page_evt_task 1 evt.action 6<br>然后卡住重启<br><strong>一般是屏幕端子没焊接好导致<br>还有可能就是屏幕和端子插座没有插好的缘故</strong><br><strong>(假如是源代码烧录的，记得看看板载的是ESP32还是ESP32-S)</strong></p><p>6、进入下载模式不成功<br>-电池和USB需要接上<br>-芯片到CH340部分的元器件焊接再次检查是否虚焊、短接<br>-检查芯片的TX RX IO0 RST VCC GND引脚是否焊接好<br>-芯片VCC电压测量下是否正常<br>-下载软件的配置是否对，固件前面的√要选上</p><p>7、屏幕一直闪、重启<br>-下载串口助手软件，查看日志根据上方排查<br>-还要检查是不是电池没电了，掉电重启</p><p>8、下载固件成功，但屏幕没显示<br>-固件是否选对？不同屏幕有不同版本固件，查看自己下单的屏幕版本<br>-屏幕连接方向是否对，可以看下图方向<br>-屏幕端子是否虚焊、短接</p><p>9、下载时提示8-download data fail<br>排查下VCC GND IO0 RST RX TX是否焊接好，插上电池，换一根USB线</p><p>10、能找到COM口，但是进入下载固件失败<br>查看下图确定引脚是否焊接好</p></blockquote><h1 id="五、参考文献"><a href="#五、参考文献" class="headerlink" title="五、参考文献"></a>五、参考文献</h1><h2 id="小智学长-amp-阿奇"><a href="#小智学长-amp-阿奇" class="headerlink" title="小智学长 &amp; 阿奇"></a>小智学长 &amp; 阿奇</h2><p>飞书文档：<a href="https://x509p6c8to.feishu.cn/docx/NQCTdjUFJoYoZ1xYHS9cIlbwnxh">https://x509p6c8to.feishu.cn/docx/NQCTdjUFJoYoZ1xYHS9cIlbwnxh</a></p><p>b站视频教程：<a href="https://www.bilibili.com/video/BV1wV4y1G7Vk/?spm_id_from=333.337.search-card.all.click&amp;vd_source=a1ef708051f7f140f22d243ecd6c0c28">【有手就行系列】嵌入式单片机教程-桌面小屏幕实战教学 从设计、硬件、焊接到代码编写、调试 ESP32 持续更新2022_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> 小项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MakeDown</title>
      <link href="/2023/01/06/MarkDown/"/>
      <url>/2023/01/06/MarkDown/</url>
      
        <content type="html"><![CDATA[<h1 id="MarkDown"><a href="#MarkDown" class="headerlink" title="MarkDown"></a>MarkDown</h1><h2 id="一、MarkDown标题"><a href="#一、MarkDown标题" class="headerlink" title="一、MarkDown标题"></a>一、MarkDown标题</h2><p>#  ————————————这是一级标题<br>##  ———————————-这是二级标题<br>### ———————————-这是三级标题<br>####  ——————————-这是四级标题<br>#####  ——————————这是五级标题<br>######  —————————-这是六级标题  </p><p><img src="/article/first_article/1.png" alt=""></p><h2 id="二、列表"><a href="#二、列表" class="headerlink" title="二、列表"></a>二、列表</h2><p>(1)有序列表  </p><blockquote><ol><li>列表1  <ol><li>列表1.1  </li><li>列表1.2  </li></ol></li></ol></blockquote><p>(2)无序列表  </p><blockquote><ul><li>列表1  <ul><li>列表1.1  </li><li>列表1.2  </li></ul></li></ul></blockquote><p><img src="/article/first_article/2.png" alt=""></p><h2 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h2><p>如果你需要在文稿中引用一段别处的句子，那么就要用到「引用」格�?,如图</p><blockquote><p>山有木兮木有枝，心悦君兮君不知的🌸  </p></blockquote><h2 id="四、图片"><a href="#四、图片" class="headerlink" title="四、图片"></a>四、图片</h2><p>通过！[ 描述]（图片的相对路径/绝对路径）的符号就能引用图片<br><img src="/article/first_article/3.webp" alt=""></p><div class="note default simple"><p>default 提示块标签</p></div><h2 id="六、时间轴"><a href="#六、时间轴" class="headerlink" title="六、时间轴"></a>六、时间轴</h2><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴样�?</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-07-24 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases">2.6.6 -&gt; 3.0</a></p></div></div><div class='timeline-item-content'><ol><li>如果�? <code>hexo-lazyload-image</code> 插件，需要删除并重新安装最新版本，设置 <code>lazyload.isSPA: true</code>�?</li><li>2.x 版本�? css �? js 不适用�? 3.x 版本，如果使用了 <code>use_cdn: true</code> 则需要删除�?</li><li>2.x 版本�? fancybox 标签�? 3.x 版本中被重命名为 gallery �?</li><li>2.x 版本的置�? <code>top: true</code> 改为�? <code>pin: true</code>，并且同样适用�? <code>layout: page</code> 的页靀�?</li><li>如果使用�? <code>hexo-offline</code> 插件，建议卸载，3.0 版本默认开启了 pjax 服务�?</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-05-15 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6">2.6.3 -&gt; 2.6.6</a></p></div></div><div class='timeline-item-content'><p>不需要额外处理�?</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-04-20 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">2.6.2 -&gt; 2.6.3</a></p></div></div><div class='timeline-item-content'><ol><li>全局搜索 <code>seotitle</code> 并替换为 <code>seo_title</code>�?</li><li>group 组件的索引规则有变，使用 group 组件的文章内，<code>group: group_name</code> 对应的组件名必须�? <code>group_name</code>�?</li><li>group 组件的列表名优先显示文章�? <code>short_title</code> 其次�? <code>title</code>�?</li></ol></div></div></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第三篇博客文�?</title>
      <link href="/2023/01/06/2023-01-03%E7%AC%AC%E4%B8%89%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2023/01/06/2023-01-03%E7%AC%AC%E4%B8%89%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="这是新建博客的第三篇文章"><a href="#这是新建博客的第三篇文章" class="headerlink" title="这是新建博客的第三篇文章"></a>这是新建博客的第三篇文章</h2><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/3dCard/in3d.css"><div id='libCategories'><div id="lib-cards" class="container"><a href='/categories/闲聊杂谈/'>  <card data-image="/img/p1.jpg">    <h1 slot="header">闲聊杂谈</h1>    <p slot="content">表达一些当时的想法，算是一个公开的类似日记的事物吧。不过不常更新。分享生活，分享经历和状态�?</p>  </card></a><a href='/categories/转载内容/'>  <card data-image="/img/p2.jpg">    <h1 slot="header">转载内容</h1>    <p slot="content">只是防止原作者站挂掉或者内容被删除所做的备份，建议访客点击访问原文进行阅读。原文地址放在文章最顶部�?</p>  </card></a></div></div><div class='js-pjax'><script src='https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vue/2.6.14/vue.min.js'></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/3dCard/in3d.js"></script></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>信号与系统复习资料</title>
      <link href="/2023/01/06/2023-01-03%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2023/01/06/2023-01-03%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="信号与系统的复习😶‍🌫️"><a href="#信号与系统的复习😶‍🌫️" class="headerlink" title="信号与系统的复习😶‍🌫️"></a>信号与系统的复习😶‍🌫️</h1><hr><p>目前还没想到有啥可以丢在这的</p><table rules="none" align="center">    <tr>        <td>            <center>                <img src="https://img-blog.csdnimg.cn/293b792757c24b8caa1ffba18ce76831.jpg" width="60%" />                <br/>            </center>        </td>        <td>            <center>                <img src="https://img-blog.csdnimg.cn/f70c9b6462314611828f3349942b1227.jpg" width="60%" />                <br/>            </center>        </td>    </tr></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/01/06/hello-world/"/>
      <url>/2023/01/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
